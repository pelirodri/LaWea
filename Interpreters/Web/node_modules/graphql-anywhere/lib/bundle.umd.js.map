{"version":3,"sources":["../src/graphql.ts","../src/utilities.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n  field: FieldNode;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues: VariableMap = {},\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (variables && !shouldInclude(selection, variables)) {\n      // Skip selection sets which we're able to determine should not be run\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n    field,\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function merge(dest, src) {\n  if (src !== null && typeof src === 'object') {\n    Object.keys(src).forEach(key => {\n      const srcVal = src[key];\n      if (!hasOwn.call(dest, key)) {\n        dest[key] = srcVal;\n      } else {\n        merge(dest[key], srcVal);\n      }\n    });\n  }\n}\n","import { DocumentNode, DirectiveNode } from 'graphql';\n\nimport { getInclusionDirectives } from 'apollo-utilities';\n\nimport { graphql, VariableMap, ExecInfo, ExecContext } from './graphql';\n\nimport { invariant } from 'ts-invariant';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport function filter<FD = any, D extends FD = any>(\n  doc: DocumentNode,\n  data: D,\n  variableValues: VariableMap = {},\n): FD {\n  if (data === null) return data;\n\n  const resolver = (\n    fieldName: string,\n    root: any,\n    args: Object,\n    context: ExecContext,\n    info: ExecInfo,\n  ) => {\n    return root[info.resultKey];\n  };\n\n  return Array.isArray(data)\n    ? data.map(dataObj => graphql(resolver, doc, dataObj, null, variableValues))\n    : graphql(resolver, doc, data, null, variableValues);\n}\n\n// TODO: we should probably make check call propType and then throw,\n// rather than the other way round, to avoid constructing stack traces\n// for things like oneOf uses in React. At this stage I doubt many people\n// are using this like that, but in the future, who knows?\nexport function check(\n  doc: DocumentNode,\n  data: any,\n  variables: VariableMap = {},\n): void {\n  const resolver = (\n    fieldName: string,\n    root: any,\n    args: any,\n    context: any,\n    info: any,\n  ) => {\n    // When variables is null, fields with @include/skip directives that\n    // reference variables are considered optional.\n    invariant(\n      hasOwnProperty.call(root, info.resultKey) ||\n        (!variables && hasVariableInclusions(info.field.directives)),\n      `${info.resultKey} missing on ${JSON.stringify(root)}`,\n    );\n    return root[info.resultKey];\n  };\n\n  graphql(resolver, doc, data, {}, variables, {\n    fragmentMatcher: () => false,\n  });\n}\n\nfunction hasVariableInclusions(\n  directives: ReadonlyArray<DirectiveNode>,\n): boolean {\n  return getInclusionDirectives(directives).some(\n    ({ ifArgument }) =>\n      ifArgument.value && ifArgument.value.kind === 'Variable',\n  );\n}\n\n// Lifted/adapted from\n//   https://github.com/facebook/react/blob/master/src/isomorphic/classic/types/ReactPropTypes.js\nconst ANONYMOUS = '<<anonymous>>';\nfunction PropTypeError(message) {\n  this.message = message;\n  this.stack = '';\n}\n// Make `instanceof Error` still work for returned errors.\nPropTypeError.prototype = Error.prototype;\n\nconst reactPropTypeLocationNames = {\n  prop: 'prop',\n  context: 'context',\n  childContext: 'child context',\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(\n    isRequired,\n    props,\n    propName,\n    componentName,\n    location,\n    propFullName,\n  ) {\n    componentName = componentName || ANONYMOUS;\n    propFullName = propFullName || propName;\n    if (props[propName] == null) {\n      const locationName = reactPropTypeLocationNames[location];\n      if (isRequired) {\n        if (props[propName] === null) {\n          return new PropTypeError(\n            `The ${locationName} \\`${propFullName}\\` is marked as required ` +\n              `in \\`${componentName}\\`, but its value is \\`null\\`.`,\n          );\n        }\n        return new PropTypeError(\n          `The ${locationName} \\`${propFullName}\\` is marked as required in ` +\n            `\\`${componentName}\\`, but its value is \\`undefined\\`.`,\n        );\n      }\n      return null;\n    } else {\n      return validate(props, propName, componentName, location, propFullName);\n    }\n  }\n\n  const chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nexport function propType(\n  doc: DocumentNode,\n  mapPropsToVariables = props => null,\n) {\n  return createChainableTypeChecker((props, propName) => {\n    const prop = props[propName];\n    try {\n      if (!prop.loading) {\n        check(doc, prop, mapPropsToVariables(props));\n      }\n      return null;\n    } catch (e) {\n      // Need a much better error.\n      // Also we aren't checking for extra fields\n      return e;\n    }\n  });\n}\n"]}